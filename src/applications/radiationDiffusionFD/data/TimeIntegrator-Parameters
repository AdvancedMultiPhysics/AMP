
TimeIntegrator {
    #outputSolution = TRUE # Write solution to file
    outputSolution = FALSE

    name = "BDF2"
    implicit_integrator = "BDF2"
    # name = "BDF1"
    # implicit_integrator = "BDF1"
    
    variable_names = ["ENERGY", "TEMPERATURE"]

    max_integrator_steps = 1000
    #max_integrator_steps = 200

    initial_time = 0.0
    final_time = 0.1
    print_info_level = 1
    
    user_managed_time_operator  = TRUE # User builds I + gamma*f
    
    # # My initial attempt (doesn't work)
    # timestep_selection_strategy = "truncationErrorStrategy"
    # pi_controller_type          = "PC.4.7"
    # timeTruncationErrorNormType = "maxNorm"
    # predictor_type              = "leapfrog"
    # problem_fixed_scaling       = 1.0, 1.0

    # # Bobby v1 (doesn't work):
    # predictor_type              = "leapfrog"
    # initial_dt            =  4.0e-04  
    # max_dt                = 1.0
    # timestep_selection_strategy =  "truncationErrorStrategy"     
    # use_pi_controller        = TRUE
    # pi_controller_type          = "PC.4.7"
    # truncation_error_rtol       = 1.0e-03
    # truncation_error_atol       = 1.0e-03
    # problem_fixed_scaling       = 1.0e-04, 0.5623413251903490808
    # #problem_fixed_scaling       = 1.0, 0.1

    # Bobby v2 (seems to work fine):
    timestep_selection_strategy = "final constant" 
    use_predictor = TRUE
    use_initial_predictor = FALSE
    predictor_type = "leapfrog"
    problem_fixed_scaling = 1.0, 1.0
    initial_dt = 1.0e-04
    max_dt = 2e-2 
    # initial_dt = 1.0e-04
    # max_dt = 1e-4

    #number of time intervals before the final constant timestep is attained
    number_of_time_intervals   = 50 # Default is 100
    # number of initial steps to take with d_initial_dt
    number_initial_fixed_steps = 10 # Default is 0

    #timestep_selection_strategy = "constant"
    #use_predictor = FALSE
    
    auto_component_scaling = FALSE # Turn off component scaling for multi-physics
    solver_name   = "Solver"

    # SNES (inexact Newton)
    Solver{
      name = "PetscSNESSolver"
      max_iterations = 6
      print_info_level = 0

      # forcing_term_strategy = "EWCHOICE3"
      # EW_choice2_alpha      = 2.0
      # EW_choice2_gamma      = 0.9

      # Check if vector satisfies constraints before applying to it
      # This line search check does help, but I still end up getting an crash sometimes---it could be from the Jacobian-FD, but as per below when I turn on that check it crashes.
      enableLineSearchPreCheck           = TRUE
      numberOfLineSearchPreCheckAttempts = 5

      # Having this enabled is throwing an error in AMP::Solver::PetscSNESSolver::mffdCheckBounds (perhaps I don't have the operator set up properly at that point or something...)
      enableMFFDBoundsCheck              = FALSE 

      # Abs tol should track truncation error
      absolute_tolerance = 1.0e-6
      relative_tolerance = 1.0e-12 
      
      stepTolerance        = 1.0e-10
      maximumFunctionEvals = 1000
      usesJacobian         = FALSE # Use Petsc FD-based approx of Jacobian

      SNESOptions = "-snes_monitor -snes_type ls -snes_converged_reason -snes_linesearch_monitor"

      # This is the Krylov solver for the Jacobian systems
      LinearSolver{
        name = "PetscKrylovSolver"
        print_info_level = 0
        max_iterations   = 40
        ksp_type = "fgmres" # Could also use bicgstab (but Bobby said not robust here)
        divergence_tolerance = 1.0e01
        max_krylov_dimension = 300
        #uses_preconditioner=FALSE
        uses_preconditioner=TRUE
        pc_type    = "shell"
        pc_side    = "RIGHT"
        KSPOptions = "-ksp_converged_reason"

        # These tols should be ignored due to EW being turned on
        absolute_tolerance   = 1.0e-8 
        relative_tolerance   = 1.0e-10

        #KSPOptions = "-ksp_monitor -ksp_converged_reason -ksp_max_it 20"

        # Let L be the approx Jacobian, then:
        # Use operator-split prec to approximately apply inv(L)
        Preconditioner{
          name = "BDFRadDifOpPJacOpSplitPrec" # Name of the prec
          absolute_tolerance = 0.0
          relative_tolerance = 0.0
          print_info_level   = 0
          max_iterations     = 1 # Number of iterations of the preconditioner
          compute_residual   = FALSE # Compute final residual
          #compute_residual   = TRUE

            # Preconditioner for approximately inverting diag diffusion blocks
            DiffusionBlocks{
              name = "BoomerAMGSolver"
              print_info_level   = 0
              min_coarse_size    = 5
              relax_type         = 6 # Hybrid GS/Jacobi
              coarsen_type       = 10
              interp_type        = 17 # distance-two
              cycle_type         = 1
              relax_order        = 0
              strong_threshold   = 0.5
              absolute_tolerance = 0.0
              relative_tolerance = 0.0
              max_iterations     = 1
            }
        }

        # # Use GMRES to "exactly apply" inv(L)
        # Preconditioner{
        #   name = "GMRESSolver"
        #   uses_preconditioner = FALSE
        #   flexible_gmres = FALSE
        #   absolute_tolerance = 0
        #   relative_tolerance = 1.0e-10
        #   print_info_level = 0
        #   max_iterations = 3
        #   max_dimension  = 300
        # }
      }
    }
}