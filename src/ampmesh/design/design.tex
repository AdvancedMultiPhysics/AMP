%%---------------------------------------------------------------------------%%
\documentclass[10pt]{article}
\usepackage[centertags]{amsmath}
\usepackage{amssymb,amsthm,graphicx}
\usepackage[mathcal]{euscript}
\usepackage{cite}

\setlength{\textwidth}{6.5in}
\setlength{\oddsidemargin}{0.0in}
\setlength{\evensidemargin}{0.0in}
\setlength{\textheight}{9.0in}
\setlength{\topmargin}{0.0in}
\setlength{\headheight}{0.0in}
\setlength{\headsep}{0.0in}
\setlength{\footskip}{0.5in}


%% These are for nice tables:
\usepackage{array}
\usepackage{ragged2e}

%%---------------------------------------------------------------------------%%
%% Define listings related stuff here.
%%---------------------------------------------------------------------------%%

\usepackage{listings}
\usepackage{color}
\usepackage{float}
\usepackage{appendix}
%% Makes citations a superscript
%\usepackage[super]{natbib}

\definecolor{listingBG}{rgb}{0.95,0.95,0.95}

\lstset{language=C++,
        showstringspaces=false,
        frame=shadowbox,
        basicstyle=\footnotesize,
        rulesepcolor=\color{black},
        backgroundcolor=\color{listingBG}}

\newfloat{sampleCode}{!ht}{lom}
\floatname{sampleCode}{Code Example}


%% Add tikz package for creating some of the figures
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}


%%---------------------------------------------------------------------------%%
%% DEFINE SPECIFIC ENVIRONMENTS HERE
%%---------------------------------------------------------------------------%%
\newenvironment{codelisting}
{\begin{list}{}{\setlength{\leftmargin}{2em}}\item\scriptsize\normalsize}
{\end{list}}


%%---------------------------------------------------------------------------%%
%% BEGIN DOCUMENT
%%---------------------------------------------------------------------------%%
\begin{document}
%%---------------------------------------------------------------------------%%

%%\setcounter{page}{2}
  
%%---------------------------------------------------------------------------%%


\vspace{0.1in}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{DETAILED SYSTEM DESIGN}
\label{sec:detailed}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This section is intended to be a higher-level supplement to the highly-detailed documentation embedded within the source code, which are 
automatically generated as HTML files by the build system through the use of the {Doxygen} software.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Mesh and Discretization}
\label{sec:overview}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This section provides the basic design of the new mesh and discretization interface.  Fig. \ref{fig:meshinheritance} shows the flow diagram for the mesh and discretization interface.  

\input{figures/MeshDescritizationFlow.tex}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Geometry}

The geometry defines the object in space.  The functionality provided is undetermined at this point.  It left open intentionally to allow for future needs. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Decomposition}

The decomposition defines how a mesh will be distributed across a given communicator.  It is mesh-type specific and open at this time.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Mesh}

A mesh is a locally supported discretization of a continuous domain defined by the geometry.  By discretization, we mean the values of a function on the continuous domain are sampled at a finite number of locations in the domain.  By locally supported, we mean a low-order piecewise interpolant through nearby points can be consistent with the continuous function throughout a subset of the domain defined by the points.  

The resulting geometric objects are referred to as vertex (points in space), edges (line connectivity between two verticies), faces (convex surface defined by 3 or more verticies), volumes (simple volume element defined by 4 or more surface elements).  The different geometric objects can be identified by their enum value (or resulting dimension), and can exist in equal or higher spatial dimension.  For example a vertex is a simple point with an enum value of 0, and can exist in any spatial dimension.  An edge is a line between 2 points, has an enum value of 1 and can exist in 1D, 2D or 3D space.  A face is convex object with an enum value of 2 and can only exist in 2D or 3D.  A volume is a simple volume object with an enum value of 3 and can only exist in 3D space.  Note that generalization to higher dimension objects is straightforward and supported through their enum value (there names have not been defined at this point).  The mesh can be viewed as the complete collection of all geometric objects and there relations.  

There are several different methods for storing meshes, the most common for scientific applications being "connectivity lists."  A connectivity list is two arrays, one that provides locations of nodes and another that provides the nodes that make up cells.  Packages such as {libMesh} rely on connectivity lists to store and manipulate meshes.  These packages provide abstractions to intuitive mesh types such as sides, faces, cells, and nodes.

Other packages such as the {SIERRA ToolKit} rely on two abstract concepts: a mesh object and a relationship.  A mesh is defined as a collection of these objects and relationships.  In these packages, a mesh object has data, such as displacement, temperature, etc., and dimensionality, a tag that indicates where in the hierarchy of mesh objects this object is placed.  A relationship is just that, a member of the set of possible relations of mesh objects.  In order to provide support for computational science, the set of possible relations is well-ordered.

These two approaches both provide the basic concepts of cell and node.  These approaches also lend themselves to use of the iterator idiom popularized by C++.  While random access of nodes and elements may require $O(\log n)$ computation, iterative access is accomplished in $O(1)$.  The {AMP} mesh relies on this idiom to abstract away from the developer the underlying storage mechanism.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{6 mm}\noindent\textbf{Mesh Class}

The mesh base class provides the basic interface for accessing and creating different mesh objects.  All mesh objects are inherited from this base class.  A brief description of the interface is given below:

\vspace{3 mm}\linebreak
\par
\noindent Constructors:
\par
There are several constructors that will create a new mesh.  The first constructor take a MeshParameters object that contains the necessary information for the construction of a new mesh.  The second constructor takes an existing mesh and returns a new mesh.  This is useful for converting one mesh object to another.  Finally, the subset command subsets the mesh given a MeshIterator, returning a new mesh.
\begin{codelisting}
\begin{verbatim}
  Mesh ( const MeshParameters::shared_ptr & );
  Mesh ( const Mesh::shared_ptr & );
  boost::shared_ptr<Mesh> Subset ( MeshIterator::shared_ptr &iterator );
\end{verbatim}
\end{codelisting}

\vspace{2 mm}\linebreak
\par
\noindent Mesh iterators:
\par
MeshIterators provide a method of iterating over a given set of mesh elements.  The mesh provides a number of default iterators of different types.  The first method will iterate over all of the objects of a given size including the specified ghost-cell-width (gcw).  GeomType is an enum that specifies the type of object that we want to iterate over (Vertex, Edge, Face, Volume).  The second iterator will iterate over the objects of a given type on the surface.  Finally, the last last command will perform basic set operations on given iterators to generate new iterator types.  SetOP is an enum that specifies the desired set operation (Union, Intersection, Complement).  
\begin{codelisting}
\begin{verbatim}
  MeshIterator getIterator ( GeomType &type, int gcw=0 );
  MeshIterator getSurfaceIterator ( GeomType &type );
  MeshIterator getIterator ( SetOP &OP, MeshIterator::shared_ptr &A, MeshIterator::shared_ptr &B);
\end{verbatim}
\end{codelisting}

\vspace{3 mm}\linebreak
\noindent Multimesh:
\par\par
Multiple meshes will be supported through the use of a MultiMesh object.  This object will inherit from the base mesh class, and will provide additional functionality by combining multiple mesh objects.  In addition to the basic iterators, an iterator over the mesh objects will also be provided.
\begin{codelisting}
\begin{verbatim}
  MultiMeshIterator getIterator ( );
\end{verbatim}
\end{codelisting}

\vspace{3 mm}\linebreak
For most applications data will be needed that exists outside the mesh defined on the local processors.  The method of accessing this data is through the use of a ghost cell width (gcw).  In this context, the ghost cell width specifies the number of neighboring objects outside the current local portion of the mesh.  The mesh is responsible for returning an iterator that includes the desired number of ghost neighbor elements.  For example given a gcw=1, the returned iterator should be able to iterate over all local elements and all immediate neighbor elements.  To limit the communication that is necessary when creating an iterator the mesh may require a maximum ghost cell width that should be supplied by the user during construction.  Then when a ghost iterator is requested, it must be <= this maximum value.  It is the mesh's responsibility to be able to create all iterators up to and including this maximum value (0<=gcw<=MAX_GCW).  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{6 mm}\noindent\textbf{MeshIterator Class}

The MeshIterator class is a C++ iterator over a group of elements.  It is provided be the Mesh base class and is the basic method that will be used to build more complex objects (such as the Discretization iterators and the DOF Manager).  The functions provided are those of a standard iterator.
\begin{codelisting}
\begin{verbatim}
Constructor:
   MeshIterator(const MeshIterator& mit);
Increment/Decrement:
   MeshIterator& operator++();
   MeshIterator operator++(int);
   MeshIterator& operator--();
   MeshIterator operator--(int);
Comparison:
   bool operator==(const MeshIterator& rhs);
   bool operator!=(const MeshIterator& rhs);
Dereference:
   MeshElement& operator*();
\end{verbatim}
\end{codelisting}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{6 mm}\noindent\textbf{MeshElement Class}

The concept of a MeshElement was previously discussed in the discussion of Mesh, and represents the storage of a simple geometric object that composes the most basic piece of a mesh.  The type of the mesh element is identified by it's enum value (vertex=0, edge=1, face=2, volume=3), and can exist in any dimension space >= it's current dimension.  The MeshElement class provides routines for accessing and itentifying mesh elements and the connectivity.
\begin{codelisting}
\begin{verbatim}
Return the element type (enum value):
   GeomType getElementType();
Return the unique global id:
   ID getGlobalId();
Return the local id:
   int getLocalId();
Return the elements composing the current element:
   vector<MeshElement> getElements(GeomType &type);
\end{verbatim}
\end{codelisting}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Discretization}

The discretization namespace provides classes needed for constructing data iterators that are used to constructing vectors on a mesh.  It represents the intermediate step of relating the mesh elements to a discretization of the function values on the given mesh.  For example, it allows the creation of basic DOF managers like a nodal scalar value and more complex operations like a finite-element discretization.  These capabilities are provided through an option VectorSpace Class, and a DOF Manager which in turn creates the DataIterators necessary for the construction of the Vectors.  The DOF Manager is also responsible for providing the relationships between a MeshElement, the degree of freedom (DOF), and the storage element in the vector.  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{6 mm}\noindent\textbf{VectorSpace Class}

The VectorSpace class provides additional functionality for discretizing the function on the mesh.  It contains information like the basis set used and feeds into the DOF Manager.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{6 mm}\noindent\textbf{DOF Manager Class}

The DOF Manager class provides the necessary relations between the mesh element the VectorSpace, the degree of freedom and the storage of the data.  It provides the necessary DataIterators for Vectors to allocate the underling storage as well as the means for identifying and accessing a particular data element.  Internally it requires a pointer to the underlying mesh, and the vector space (if used).  Optionally it may provide for a different parallel decomposition from the underlying mesh.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{6 mm}\noindent\textbf{DataIterator Class}

The DataIterator is a basic iterator that allows for the construction of data objects (like Vectors).  The relationship between a particular data element, a mesh element, and the degrees of freedom is determined by the DOF Manager which created the given DataIterator




\end{document}


