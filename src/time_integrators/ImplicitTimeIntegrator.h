#ifndef included_ImplicitTimeIntegrator
#define included_ImplicitTimeIntegrator

#ifndef included_AMP_config

#endif
#ifndef included_AMP_Vector
#include "vectors/Vector.h"
#endif
#ifndef included_tbox_InputDatabase
#include "utils/InputDatabase.h"
#endif
#ifndef included_tbox_Pointer
#include "utils/shared_ptr.h"
#endif
#ifndef included_TimeIntegrator
#include "TimeIntegrator.h"
#endif

#ifndef included_SolverStrategy
#include "solvers/SolverStrategy.h"
#endif

#include "TimeOperatorParameters.h"

/*Design-By-Contract Macros*/
#include "utils/Utilities.h"

#include <string>
#include <ostream>

namespace AMP{
namespace TimeIntegrator{


/*!
  @brief Manage implicit time integration

  Class ImplicitTimeIntegrator manages implicit time integration. It maintains references
  to a TimeOperator and SolverStrategy
  objects. The TimeOperator describe the implicit equations at each time step
  and the SolverStrategy solves the problem at each time step.
  
  Initialization of an ImplicitTimeIntegrator object is performed via a
  combination of default parameters and values read from input.  Data
  read from input is summarized as follows:
 
  Required input keys and data types:
  @param initial_time double value for the initial simulation time.
  @param final_time double value for the final simulation time.
  @param max_integrator_steps integer value for the maximum number
  of timesteps allowed.
 
  All input data items described above, except for initial_time,
  may be overwritten by new input values when continuing from restart.
 
  A sample input file entry might look like:
 
  @code
  initial_time = 0.0
  final_time   = 1.0
  max_integrator_steps = 100
  @endcode
 
  @see Operator
  @see SolverStrategy
 */
class ImplicitTimeIntegrator: public TimeIntegrator
{
public:
   /**
    * The constructor for ImplicitTimeIntegrator initializes the 
    * default state of the integrator.  The integrator is configured with 
    * the concrete strategy objects in the argument list that provide 
    * operations related to the nonlinear solver and implicit equations 
    * to solve.  Data members are initialized from the input and restart 
    * databases. 
    * 
    * Note that no vectors are created in the constructor.  Vectors are
    * created and the nonlinear solver is initialized in the initialize()
    * member function.
    *
    */
  ImplicitTimeIntegrator( AMP::shared_ptr< TimeIntegratorParameters > parameters);

   /**
    * Empty destructor for ImplicitTimeIntegrator
    */
   virtual ~ImplicitTimeIntegrator();

   /**
    * Initialize state of time integrator.  This includes creating
    * solution vector and initializing solver components.
    */
   void initialize( AMP::shared_ptr< TimeIntegratorParameters > parameters);

   /**
   * Resets the internal state of the time integrator as needed.
   * A parameter argument is passed to allow for general flexibility
   * in determining what needs to be reset Typically used after a regrid.
   */
   virtual void reset( AMP::shared_ptr< TimeIntegratorParameters > parameters) = 0;

   /*!
    * @brief Integrate through the
    * specified time increment.
    *
    * Integrate through the specified time 
    * increment.  The time advance assumes the use of a nonlinear 
    * solver to implicitly integrate the discrete equations.  The integer
    * return value is the return code generated by the particular solver
    * package in use.  It is the user's responsibility to interpret this
    * code in a manner consistent with the solver she is using.
    *
    * The boolean first_step argument is true when this is the very
    * first call to the advance function or if the call occurs immediately 
    * after the hierarchy has changed due to regridding.  Otherwise it is 
    * false.  Note that, when the argument is true, the use of extrapolation 
    * to construct the initial guess for the advanced solution may not be 
    * possible.  
    *
    *
    * @param dt Time step size
    * @param first_step Whether this is the first step after grid change
    *
    * @return value is the return code generated by the particular solver
    * package in use
    */
   virtual int advanceSolution( const double dt, const bool first_step );

   /**
    * Return time increment for next solution advance.  Timestep selection
    * is generally based on whether the nonlinear solution iteration 
    * converged and, if so, whether the solution meets some user-defined 
    * criteria.  This routine assumes that, before it is called, the 
    * routine checkNewSolution() was called.  The boolean argument is the 
    * return value from that call.  The integer argument is the return code 
    * generated by the nonlinear solver package that computed the solution. 
    */
   virtual double getNextDt(const bool good_solution) = 0;

   /**
    * Check time advanced solution to determine whether it is acceptable.
    * Return true if the solution is acceptable; return false otherwise.
    * The integer argument is the return code generated by the call to the
    * nonlinear solver "solve" routine.   The meaning of this value depends
    * on the particular nonlinear solver in use and must be intepreted 
    * properly by the user-supplied solution checking routine.
    */
   virtual bool checkNewSolution(void) const = 0;

   /**
    * Update solution (e.g., reset pointers for solution data, update 
    * dependent variables, etc.) after time advance.  It is assumed that 
    * when this routine is invoked, an acceptable new solution has been 
    * computed.  The double return value is the simulation time corresponding
    * to the advanced solution.
    */
   virtual void updateSolution( void ) = 0;

   /**
    * Print out all members of integrator instance to given output stream.
    */
   void printClassData(std::ostream& os) const;

   /**
    * Write out state of object to given database.
    *
    * When assertion checking is active, the database pointer must be non-null.
    */
   void putToDatabase(AMP::shared_ptr<AMP::Database> db);

   AMP::shared_ptr<AMP::Solver::SolverStrategy> getSolver(void){ return d_solver; }

 protected:
      virtual void initializeTimeOperator(AMP::shared_ptr< TimeIntegratorParameters > parameters);

      /*
       * Pointer to solver objects and patch
       * hierarchy.  The strategies provide nonlinear equation and solver 
       * routines for treating the nonlinear problem on the hierarchy.
       */
      AMP::shared_ptr<AMP::Solver::SolverStrategy> d_solver;
      
      AMP::shared_ptr< TimeOperatorParameters > d_pTimeOperatorParameters;
private:
   /*
    * Read input data from specified database and initialize class members.
    * If run is from restart, a subset of the restart values may be replaced
    * with those read from input.
    *
    * When assertion checking is active, the database pointer must be non-null.
    */
   void getFromInput(AMP::shared_ptr<AMP::Database> db);

   /*
    * Read object state from restart database and initialize class members.
    * Check that class and restart version numbers are the same.
    */
   void getFromRestart();

   /**
    * Set initial guess for time advanced solution vector.  The first_step
    * is true if the subsequent time advance is the first in the simulation,
    * or if it immediately follows a regridding of the patch hierarchy.  In 
    * either case, extrapolation of the solution may not be possible since
    * there may be no old solution to use.  Otherwise, first_step is false.  
    * The current_time argument is the current solution time.  The 
    * current_dt and old_dt arguments represent the time increments 
    * used in the cuurent and previous advances, respectively.  Thus, the
    * new integration time to which we will attempt to advance the solution
    * will be current_time + current_dt.
    */ 
   virtual void setInitialGuess(const bool first_step,
                                const double current_time,
                                const double current_dt,
                                const double old_dt) = 0;

   // The following are not implemented:
   ImplicitTimeIntegrator(const ImplicitTimeIntegrator&);
   void operator=(const ImplicitTimeIntegrator&);

};

}
}

#endif 

